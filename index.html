<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ragdoll Engine Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,0.85); color: white; padding: 15px; border-radius: 12px; border: 1px solid #444; width: 220px; }
        canvas { display: block; touch-action: none; }
        button, input[type="file"] { margin-top: 10px; width: 100%; padding: 8px; cursor: pointer; border-radius: 5px; border: none; }
        button { background: #444; color: white; font-weight: bold; transition: 0.2s; }
        button:hover { background: #666; }
        .hint { font-size: 0.75em; color: #888; margin-top: 8px; line-height: 1.2; }
    </style>
</head>
<body>

    <div id="ui">
        <strong style="font-size: 1.1em;">Ragdoll Studio</strong>
        <p class="hint">Fond :</p>
        <input type="color" id="bgColor" value="#00ff00">
        <input type="file" id="fileInput" accept=".glb,.gltf">
        <button id="resetBtn">Réinitialiser Position</button>
        <div class="hint">
            • <b>Drag</b> : Secouer le membre<br>
            • <b>1 Doigt/Clic</b> : Rotation vue<br>
            • <b>Pincer/Molette</b> : Zoom
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // --- SCÈNE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x00ff00);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); // Position par défaut éloignée

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 0.5;
        controls.maxDistance = 20;

        const ambient = new THREE.AmbientLight(0xffffff, 0.9);
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(5, 10, 5);
        scene.add(ambient, sun);

        // --- PHYSIQUE ---
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.81, 0) });
        const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        let ragdollParts = [];
        let mouseConstraint = null;
        const dummyBody = new CANNON.Body({ mass: 0 });
        dummyBody.collisionFilterGroup = 0; 
        world.addBody(dummyBody);

        // --- INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function syncMouse(e) {
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
        }

        window.addEventListener('pointerdown', (e) => {
            syncMouse(e);
            raycaster.setFromCamera(mouse, camera);
            
            // On cherche le membre le plus proche du clic
            let closestPart = null;
            let minDist = 0.5; 

            ragdollParts.forEach(p => {
                const screenPos = p.bone.getWorldPosition(new THREE.Vector3()).project(camera);
                const d = mouse.distanceTo(new THREE.Vector2(screenPos.x, screenPos.y));
                if (d < minDist) {
                    minDist = d;
                    closestPart = p;
                }
            });

            if (closestPart) {
                controls.enabled = false;
                mouseConstraint = new CANNON.PointToPointConstraint(
                    closestPart.body, new CANNON.Vec3(0,0,0), 
                    dummyBody, new CANNON.Vec3(0,0,0), 1500
                );
                world.addConstraint(mouseConstraint);
            }
        });

        window.addEventListener('pointermove', (e) => {
            syncMouse(e);
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const dist = camera.position.distanceTo(controls.target);
            dummyBody.position.copy(camera.position.clone().add(dir.multiplyScalar(dist)));
        });

        window.addEventListener('pointerup', () => {
            controls.enabled = true;
            if (mouseConstraint) {
                world.removeConstraint(mouseConstraint);
                mouseConstraint = null;
            }
        });

        // --- IMPORT ---
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            new GLTFLoader().load(URL.createObjectURL(file), (gltf) => {
                const model = gltf.scene;
                scene.add(model);
                
                // --- PLACEMENT CAMÉRA ---
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                
                controls.target.copy(center);
                camera.position.set(center.x, center.y + size.y/2, center.z + size.y * 2);
                controls.update();

                // --- CRÉATION PHYSIQUE ---
                model.traverse(bone => {
                    if(bone.isBone) {
                        const body = new CANNON.Body({ 
                            mass: 1, 
                            shape: new CANNON.Sphere(0.12),
                            linearDamping: 0.2,
                            angularDamping: 0.2 
                        });
                        const pos = new THREE.Vector3();
                        bone.getWorldPosition(pos);
                        body.position.copy(pos);
                        
                        world.addBody(body);
                        ragdollParts.push({ bone, body, initPos: pos.clone() });

                        if (bone.parent && bone.parent.isBone) {
                            const parentPart = ragdollParts.find(p => p.bone === bone.parent);
                            if (parentPart) {
                                world.addConstraint(new CANNON.PointToPointConstraint(body, new CANNON.Vec3(0,0,0), parentPart.body, new CANNON.Vec3(0,0,0)));
                            }
                        }
                    }
                });
            });
        });

        // RESET
        document.getElementById('resetBtn').onclick = () => {
            ragdollParts.forEach(p => {
                p.body.position.copy(p.initPos);
                p.body.velocity.set(0,0,0);
                p.body.angularVelocity.set(0,0,0);
            });
        };

        document.getElementById('bgColor').oninput = (e) => scene.background.set(e.target.value);

        function animate() {
            requestAnimationFrame(animate);
            world.fixedStep();
            controls.update();

            ragdollParts.forEach(p => {
                p.bone.position.copy(p.body.position);
                p.bone.quaternion.copy(p.body.quaternion);
                if(p.bone.parent) p.bone.parent.worldToLocal(p.bone.position);
            });

            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
